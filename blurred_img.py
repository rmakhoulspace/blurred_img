# -*- coding: utf-8 -*-
"""Blurred_img.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZKhofJ4n2y2q5Nnnl0Umb9ujLv6egJjD
"""

# Step 2.1: Download the JPEG from your link
!wget "https://images.rawpixel.com/image_800/cHJpdmF0ZS9sci9pbWFnZXMvd2Vic2l0ZS8yMDIyLTA1L3B4MTU4NDc5NS1pbWFnZS1rd3Z4dmsyeS5qcGc.jpg" -O test.jpg

# Step 2.2: Check the file size and format
!ls -l test.jpg
!file test.jpg

# Step 3.1: Install ImageMagick (if not already installed)
!sudo apt-get update
!sudo apt-get install imagemagick -y

# Step 3.2: Convert the JPEG to PNG
!convert test.jpg test.png

# Step 3.3: Check the PNG size and format
!ls -l test.png
!file test.png

from IPython.display import Image
Image('test.png')

# Step 4: Download lodepng header and source
!wget https://raw.githubusercontent.com/lvandeve/lodepng/master/lodepng.h -O lodepng.h
!wget https://raw.githubusercontent.com/lvandeve/lodepng/master/lodepng.cpp -O lodepng.cpp

# Commented out IPython magic to ensure Python compatibility.
# %%writefile blur_kernel.cu
# #include <cuda_runtime.h>
# #include <stdio.h>
# #include <stdlib.h>
# #include "lodepng.h"
# 
# #define BLUR_SIZE 2
# 
# __global__
# void blurKernel(const unsigned char* in, unsigned char* out, int w, int h)
# {
#     int col = blockIdx.x * blockDim.x + threadIdx.x;
#     int row = blockIdx.y * blockDim.y + threadIdx.y;
#     if (col < w && row < h) {
#         for (int channel = 0; channel < 4; channel++) {
#             int pixelSum = 0;
#             int pixelCount = 0;
#             for (int blurRow = -BLUR_SIZE; blurRow <= BLUR_SIZE; blurRow++) {
#                 for (int blurCol = -BLUR_SIZE; blurCol <= BLUR_SIZE; blurCol++) {
#                     int curRow = row + blurRow;
#                     int curCol = col + blurCol;
#                     if (curRow >= 0 && curRow < h && curCol >= 0 && curCol < w) {
#                         int offset = (curRow * w + curCol) * 4 + channel;
#                         pixelSum += in[offset];
#                         pixelCount++;
#                     }
#                 }
#             }
#             out[(row * w + col) * 4 + channel] = pixelSum / pixelCount;
#         }
#     }
# }
# 
# int main(int argc, char* argv[])
# {
#     if (argc != 3) {
#         printf("Usage: %s <input.png> <output.png>\\n", argv[0]);
#         return 1;
#     }
# 
#     const char* inputPath = argv[1];
#     const char* outputPath = argv[2];
# 
#     unsigned w, h;
#     unsigned char *hostIn = nullptr, *hostOut = nullptr;
#     unsigned char *devIn = nullptr, *devOut = nullptr;
# 
#     // 1. Load the PNG
#     unsigned error = lodepng_decode32_file(&hostIn, &w, &h, inputPath);
#     if (error) {
#         printf("Error loading image: %s\\n", lodepng_error_text(error));
#         return 1;
#     }
#     printf("Loaded image: width=%u, height=%u\\n", w, h);
# 
#     size_t imageSize = (size_t) w * h * 4;
#     hostOut = (unsigned char*)malloc(imageSize);
# 
#     // Debug: input
#     printf("First 12 bytes of hostIn: ");
#     for (int i=0; i<12; i++)
#         printf("%d ", hostIn[i]);
#     printf("\\n");
# 
#     cudaMalloc(&devIn, imageSize);
#     cudaMalloc(&devOut, imageSize);
# 
#     cudaMemcpy(devIn, hostIn, imageSize, cudaMemcpyHostToDevice);
# 
#     // 2. Launch blur kernel
#     dim3 block(16,16);
#     dim3 grid((w + block.x - 1)/block.x, (h + block.y - 1)/block.y);
# 
#     blurKernel<<<grid, block>>>(devIn, devOut, w, h);
# 
#     // Check for kernel errors
#     cudaError_t err = cudaGetLastError();
#     if (err != cudaSuccess) {
#         printf("Kernel launch error: %s\\n", cudaGetErrorString(err));
#     }
#     cudaDeviceSynchronize();
#     err = cudaGetLastError();
#     if (err != cudaSuccess) {
#         printf("Kernel sync error: %s\\n", cudaGetErrorString(err));
#     }
# 
#     // 3. Copy result back
#     cudaMemcpy(hostOut, devOut, imageSize, cudaMemcpyDeviceToHost);
# 
#     // Debug: output
#     printf("First 12 bytes of hostOut: ");
#     for (int i=0; i<12; i++)
#         printf("%d ", hostOut[i]);
#     printf("\\n");
# 
#     // 4. Encode result
#     error = lodepng_encode32_file(outputPath, hostOut, w, h);
#     if (error) {
#         printf("Error saving image: %s\\n", lodepng_error_text(error));
#         return 1;
#     }
#     printf("Blurred image saved to %s\\n", outputPath);
# 
#     cudaFree(devIn);
#     cudaFree(devOut);
#     free(hostIn);
#     free(hostOut);
# 
#     return 0;
# }
#

!ls -l test.png
!file test.png

from IPython.display import Image
Image('test.png')

# Commented out IPython magic to ensure Python compatibility.
# %%writefile image_blur_tiled.cu
# #include <cuda_runtime.h>
# #include <stdio.h>
# #include <stdlib.h>
# #include "lodepng.h"
# 
# // Tune these as needed
# #define BLUR_SIZE 5
# #define TILE_WIDTH 16 // 16x16 threads per block
# 
# // ---------------------------------------------------------
# // Tiled Blur Kernel
# // ---------------------------------------------------------
# __global__
# void blurKernelTiled(const unsigned char* in, unsigned char* out, int w, int h)
# {
#     // We handle RGBA channels (4).
#     // Each thread block will load a "tile" plus a border region for the blur.
# 
#     // Calculate each thread's global row/col in the image
#     int col = blockIdx.x * blockDim.x + threadIdx.x;
#     int row = blockIdx.y * blockDim.y + threadIdx.y;
# 
#     // Size of the shared memory tile:
#     // We'll allocate a (TILE_WIDTH + 2*BLUR_SIZE) x (TILE_WIDTH + 2*BLUR_SIZE) region
#     // for each of the 4 channels. Another approach is to store them in a single array
#     // with 4 channels interleaved, but let's keep it simple: we'll load RGBA in one pass.
#     extern __shared__ unsigned char sharedMem[]; // dynamic shared memory
# 
#     // We'll break it into 4 slices (one per channel), each slice big enough for
#     // (TILE_WIDTH + 2*BLUR_SIZE)^2. Or we can do a single chunk but index differently.
# 
#     int tileSize = (TILE_WIDTH + 2*BLUR_SIZE) * (TILE_WIDTH + 2*BLUR_SIZE);
#     unsigned char* tileR = sharedMem;                  // first tile
#     unsigned char* tileG = sharedMem + tileSize;       // second
#     unsigned char* tileB = sharedMem + 2 * tileSize;   // third
#     unsigned char* tileA = sharedMem + 3 * tileSize;   // fourth
# 
#     // Each thread will load 1 pixel for each channel in the extended tile region.
#     // But first let's figure out the "top-left" corner in global coordinates
#     int tileStartCol = blockIdx.x * TILE_WIDTH - BLUR_SIZE;
#     int tileStartRow = blockIdx.y * TILE_WIDTH - BLUR_SIZE;
# 
#     // Our local row/col in the shared tile
#     int localCol = threadIdx.x;
#     int localRow = threadIdx.y;
# 
#     // Now we loop to fill the entire tile with each thread possibly reading multiple
#     // "covering" steps. A simpler approach is to do a 1:1 mapping: each thread loads
#     // exactly one pixel from the global image into the shared tile. Then we rely on
#     // blockDim.x * blockDim.y being big enough to cover the tile + border. However,
#     // we used TILE_WIDTH=16, and we might need up to 16+2*BLUR_SIZE = 20 in each dimension.
# 
#     // Easiest approach: let the block dimension be (TILE_WIDTH + 2*BLUR_SIZE),
#     // but let's keep it simple and do a boundary check.
# 
#     // Global coordinates of the pixel we're loading for each channel:
#     int globalCol = tileStartCol + localCol;
#     int globalRow = tileStartRow + localRow;
# 
#     // Make sure we don't go out of the image
#     // We'll clamp inside 0..w-1 and 0..h-1 for reading
#     int readCol = min(max(globalCol, 0), w - 1);
#     int readRow = min(max(globalRow, 0), h - 1);
# 
#     int globalOffset = (readRow * w + readCol) * 4;
#     // Load each channel
#     int localOffset = (localRow * (TILE_WIDTH + 2*BLUR_SIZE)) + localCol;
# 
#     // If localOffset is in range of the allocated tile
#     // (it should be, as long as threadIdx.x, threadIdx.y < TILE_WIDTH + 2*BLUR_SIZE).
#     tileR[localOffset] = in[globalOffset + 0];
#     tileG[localOffset] = in[globalOffset + 1];
#     tileB[localOffset] = in[globalOffset + 2];
#     tileA[localOffset] = in[globalOffset + 3];
# 
#     // Wait for all threads to load data
#     __syncthreads();
# 
#     // Now, the main portion of each block is actually computing the blur
#     // for col,row in [blockIdx.x * TILE_WIDTH, blockIdx.x * TILE_WIDTH + TILE_WIDTH)
#     // ignoring the border threads if we have them. But let's do a boundary check instead:
#     if (col < w && row < h) {
#         // We want to blur (col,row). We'll read from the shared memory
#         // offset by BLUR_SIZE in each dimension
#         int localFocusCol = localCol;
#         int localFocusRow = localRow;
# 
#         // We'll compute for RGBA channels
#         for (int channel = 0; channel < 4; channel++) {
#             int pixelSum = 0;
#             int pixelCount = 0;
# 
#             // We'll blur within BLUR_SIZE around (col,row)
#             for (int blurRow = -BLUR_SIZE; blurRow <= BLUR_SIZE; blurRow++) {
#                 for (int blurCol = -BLUR_SIZE; blurCol <= BLUR_SIZE; blurCol++) {
#                     int localReadRow = localFocusRow + blurRow;
#                     int localReadCol = localFocusCol + blurCol;
# 
#                     // Make sure we don't go out of the tile in local coords
#                     if (localReadRow >= 0 && localReadRow < (TILE_WIDTH + 2*BLUR_SIZE) &&
#                         localReadCol >= 0 && localReadCol < (TILE_WIDTH + 2*BLUR_SIZE))
#                     {
#                         int tileIndex = localReadRow * (TILE_WIDTH + 2*BLUR_SIZE) + localReadCol;
#                         unsigned char val;
#                         // pick which tile to read from
#                         if (channel == 0) {
#                             val = tileR[tileIndex];
#                         } else if (channel == 1) {
#                             val = tileG[tileIndex];
#                         } else if (channel == 2) {
#                             val = tileB[tileIndex];
#                         } else {
#                             val = tileA[tileIndex];
#                         }
#                         pixelSum += val;
#                         pixelCount++;
#                     }
#                 }
#             }
# 
#             // Write the result to the global 'out'
#             int outOffset = (row * w + col) * 4 + channel;
#             out[outOffset] = (unsigned char)(pixelSum / pixelCount);
#         }
#     }
# }
# 
# int main(int argc, char* argv[])
# {
#     if (argc != 3) {
#         printf("Usage: %s <input.png> <output.png>\n", argv[0]);
#         return 1;
#     }
# 
#     const char* inputPath = argv[1];
#     const char* outputPath = argv[2];
# 
#     unsigned char *hostIn, *hostOut;
#     unsigned char *devIn, *devOut;
#     unsigned w, h;
# 
#     // 1. Decode PNG -> RGBA
#     unsigned error = lodepng_decode32_file(&hostIn, &w, &h, inputPath);
#     if (error) {
#         printf("Error loading image: %s\n", lodepng_error_text(error));
#         return 1;
#     }
#     printf("Loaded image: width=%u, height=%u\n", w, h);
# 
#     size_t imageSize = (size_t)w * h * 4;
#     hostOut = (unsigned char*)malloc(imageSize);
# 
#     cudaMalloc(&devIn, imageSize);
#     cudaMalloc(&devOut, imageSize);
# 
#     cudaMemcpy(devIn, hostIn, imageSize, cudaMemcpyHostToDevice);
# 
#     // 2. Launch the tiled blur kernel
#     dim3 blockDim(TILE_WIDTH + 2*BLUR_SIZE, TILE_WIDTH + 2*BLUR_SIZE);
#     // Or you might keep blockDim = (TILE_WIDTH, TILE_WIDTH) and do multiple loads per thread,
#     // but let's do the simpler approach here: each thread loads exactly one pixel in the tile + border.
#     dim3 gridDim((w + TILE_WIDTH - 1) / TILE_WIDTH,
#                  (h + TILE_WIDTH - 1) / TILE_WIDTH);
# 
#     // We need enough shared memory for 4 "tiles": RGBA channels
#     // Each tile is (TILE_WIDTH+2*BLUR_SIZE)^2 bytes
#     int tileExtent = TILE_WIDTH + 2 * BLUR_SIZE;
#     size_t sharedMemSize = 4 * (tileExtent * tileExtent) * sizeof(unsigned char);
# 
#     // Timed launch
#     cudaEvent_t start, stop;
#     cudaEventCreate(&start);
#     cudaEventCreate(&stop);
#     cudaEventRecord(start);
# 
#     blurKernelTiled<<<gridDim, blockDim, sharedMemSize>>>(devIn, devOut, w, h);
# 
#     cudaEventRecord(stop);
#     cudaEventSynchronize(stop);
# 
#     float ms=0.0f;
#     cudaEventElapsedTime(&ms, start, stop);
#     printf("Tiled Blur Kernel Execution Time: %f ms\n", ms);
# 
#     // 3. Copy results back
#     cudaMemcpy(hostOut, devOut, imageSize, cudaMemcpyDeviceToHost);
# 
#     // 4. Encode PNG
#     error = lodepng_encode32_file(outputPath, hostOut, w, h);
#     if (error) {
#         printf("Error saving image: %s\n", lodepng_error_text(error));
#         return 1;
#     }
#     printf("Tiled blurred image saved to %s\n", outputPath);
# 
#     // Cleanup
#     cudaFree(devIn);
#     cudaFree(devOut);
#     free(hostIn);
#     free(hostOut);
# 
#     return 0;
# }
#

!nvcc -arch=sm_75 image_blur_tiled.cu lodepng.cpp -o image_blur_tiled

!./image_blur_tiled test.png tiled_output.png

!ls -l tiled_output.png
!file tiled_output.png

from IPython.display import Image
Image('tiled_output.png')